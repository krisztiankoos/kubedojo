# Module 1.3: Filesystem Hierarchy

> **Linux Foundations** | Complexity: `[MEDIUM]` | Time: 25-30 min

## Prerequisites

Before starting this module:
- **Required**: [Module 1.1: Kernel & Architecture](module-1.1-kernel-architecture.md)
- **Helpful**: [Module 1.2: Processes & systemd](module-1.2-processes-systemd.md)

---

## Why This Module Matters

On Linux, **everything is a file**. Configuration, devices, processes, network connections—all represented in the filesystem.

Understanding the filesystem hierarchy is essential because:

- **Finding files** — Where's the config? Where are the logs?
- **Troubleshooting** — /proc and /sys expose system internals
- **Container images** — They're just filesystem layers
- **Security** — Knowing what should be where helps spot anomalies

When you see `/var/lib/kubelet` or `/etc/kubernetes`, you should instinctively know what kind of files live there.

---

## Did You Know?

- **The Filesystem Hierarchy Standard (FHS) dates back to 1994** and is maintained by the Linux Foundation. It ensures that binaries, libraries, and configuration files are in predictable locations across all Linux distributions.

- **Everything really is a file in Linux** — even hardware devices. Your keyboard is `/dev/input/event0`, your hard drive is `/dev/sda`, and your RAM can be accessed (dangerously!) via `/dev/mem`.

- **/proc isn't on disk** — It's a virtual filesystem generated by the kernel in real-time. Reading `/proc/meminfo` doesn't read from disk; the kernel creates the content when you access it.

- **Container images average 200+ MB** but often only contain 20-50 MB of unique files. The rest are standard Linux directories and shared libraries—the same FHS structure you're learning now.

---

## The Filesystem Hierarchy Standard

```
/                           ← Root of everything
├── bin/                    ← Essential command binaries
├── boot/                   ← Boot loader files, kernel
├── dev/                    ← Device files
├── etc/                    ← System configuration
├── home/                   ← User home directories
├── lib/                    ← Essential shared libraries
├── lib64/                  ← 64-bit libraries
├── media/                  ← Removable media mount points
├── mnt/                    ← Temporary mount points
├── opt/                    ← Optional/third-party software
├── proc/                   ← Virtual: process information
├── root/                   ← Root user's home directory
├── run/                    ← Runtime variable data
├── sbin/                   ← System binaries (admin)
├── srv/                    ← Service data
├── sys/                    ← Virtual: kernel/device info
├── tmp/                    ← Temporary files
├── usr/                    ← Secondary hierarchy
│   ├── bin/                ← User commands
│   ├── lib/                ← Libraries
│   ├── local/              ← Locally installed software
│   └── share/              ← Shared data
└── var/                    ← Variable data
    ├── log/                ← Log files
    ├── lib/                ← Persistent program data
    └── run/                ← Runtime data (symlink to /run)
```

---

## Directory Deep Dive

### /etc — Configuration Central

**Everything** is configured here.

```bash
/etc/
├── passwd                  # User accounts
├── shadow                  # Password hashes
├── group                   # Groups
├── hosts                   # Static hostname mappings
├── resolv.conf             # DNS resolver config
├── fstab                   # Filesystem mount table
├── crontab                 # System cron jobs
├── ssh/                    # SSH configuration
│   ├── sshd_config         # SSH server config
│   └── ssh_config          # SSH client config
├── systemd/                # systemd configuration
│   └── system/             # System unit files
├── kubernetes/             # K8s node configuration
│   ├── manifests/          # Static pod manifests
│   ├── pki/                # Certificates
│   └── kubelet.conf        # Kubelet config
└── containerd/             # Container runtime config
    └── config.toml
```

```bash
# Explore /etc
ls /etc | head -20

# Configuration file types
file /etc/passwd /etc/ssh/sshd_config /etc/hosts
```

### /var — Variable Data

Data that changes during system operation.

```bash
/var/
├── log/                    # Log files
│   ├── syslog              # System log
│   ├── auth.log            # Authentication log
│   ├── kern.log            # Kernel log
│   ├── containers/         # Container logs
│   └── pods/               # Pod logs (K8s)
├── lib/                    # Persistent application data
│   ├── docker/             # Docker data
│   ├── containerd/         # containerd data
│   ├── kubelet/            # Kubelet data
│   │   └── pods/           # Pod volumes
│   └── etcd/               # etcd database
├── run/                    # Runtime data (→ /run)
├── cache/                  # Application cache
└── tmp/                    # Temporary files (preserved across reboots)
```

```bash
# Check disk usage in /var
du -sh /var/* 2>/dev/null | sort -h

# Find large log files
find /var/log -type f -size +10M 2>/dev/null
```

### /proc — Process Pseudo-Filesystem

Virtual filesystem exposing kernel and process information.

```bash
/proc/
├── 1/                      # PID 1 (init/systemd)
│   ├── cmdline             # Command line
│   ├── cwd                 # Current working directory (symlink)
│   ├── environ             # Environment variables
│   ├── exe                 # Executable (symlink)
│   ├── fd/                 # File descriptors
│   ├── maps                # Memory maps
│   ├── status              # Process status
│   └── ns/                 # Namespaces
├── cpuinfo                 # CPU information
├── meminfo                 # Memory information
├── loadavg                 # Load average
├── uptime                  # System uptime
├── mounts                  # Mounted filesystems
├── net/                    # Network information
│   ├── dev                 # Network device stats
│   ├── tcp                 # TCP connections
│   └── route               # Routing table
└── sys/                    # Kernel parameters (tunable)
    ├── kernel/
    ├── net/
    └── vm/
```

```bash
# System info from /proc
cat /proc/cpuinfo | grep "model name" | head -1
cat /proc/meminfo | head -5
cat /proc/loadavg

# Process info
cat /proc/$$/cmdline | tr '\0' ' '  # Your shell's command
ls -la /proc/$$/fd                   # Open file descriptors
cat /proc/$$/status | grep -E "^(Name|State|Pid|PPid|Uid)"
```

### /sys — Kernel Object Pseudo-Filesystem

Exposes kernel objects, devices, and drivers.

```bash
/sys/
├── block/                  # Block devices
│   └── sda/
│       ├── size            # Size in 512-byte sectors
│       └── queue/          # I/O scheduler settings
├── class/                  # Device classes
│   ├── net/                # Network interfaces
│   └── block/              # Block devices
├── devices/                # Device hierarchy
├── fs/                     # Filesystem info
│   └── cgroup/             # Cgroup information
└── kernel/                 # Kernel configuration
    └── mm/                 # Memory management
```

```bash
# Network interface info
ls /sys/class/net

# Block device info
cat /sys/block/sda/size 2>/dev/null || cat /sys/block/vda/size

# Check cgroup version
cat /sys/fs/cgroup/cgroup.controllers 2>/dev/null && echo "cgroup v2" || echo "cgroup v1 or check manually"
```

### /dev — Device Files

Special files representing hardware and pseudo-devices.

```bash
/dev/
├── null                    # Discard all data written
├── zero                    # Provides endless zero bytes
├── random                  # Random number generator (blocking)
├── urandom                 # Random number generator (non-blocking)
├── tty                     # Current terminal
├── stdin                   # Standard input (→ fd/0)
├── stdout                  # Standard output (→ fd/1)
├── stderr                  # Standard error (→ fd/2)
├── sda                     # First SCSI/SATA disk
│   ├── sda1                # First partition
│   └── sda2                # Second partition
├── loop0                   # Loop device
└── pts/                    # Pseudo-terminals
    └── 0                   # First pseudo-terminal
```

```bash
# Classic uses
echo "hello" > /dev/null    # Discard output
head -c 16 /dev/urandom | xxd  # Random bytes
dd if=/dev/zero bs=1M count=1 | wc -c  # 1MB of zeros
```

---

## Inodes: The Real File Identity

An **inode** (index node) is the actual file metadata structure.

### What an Inode Contains

```
┌─────────────────────────────────────────┐
│              INODE                       │
├─────────────────────────────────────────┤
│  File type (regular, directory, etc.)   │
│  Permissions (rwx)                       │
│  Owner (UID)                             │
│  Group (GID)                             │
│  Size                                    │
│  Timestamps (atime, mtime, ctime)        │
│  Number of hard links                    │
│  Pointers to data blocks                 │
└─────────────────────────────────────────┘
         │
         │  (NOT the filename!)
         │
         ▼
┌─────────────────────────────────────────┐
│           DATA BLOCKS                    │
│     (actual file content)                │
└─────────────────────────────────────────┘
```

**Important**: The filename is NOT in the inode. It's in the directory entry.

### Viewing Inodes

```bash
# See inode numbers
ls -li /etc/passwd

# Output: 123456 -rw-r--r-- 1 root root 2345 Dec 1 /etc/passwd
#         ^^^^^^ = inode number

# Detailed inode info
stat /etc/passwd
```

### Hard Links vs Symbolic Links

```
HARD LINK                           SYMBOLIC LINK
┌─────────────┐                    ┌─────────────┐
│ filename1   │───┐                │  symlink    │
└─────────────┘   │                └──────┬──────┘
                  ▼                       │ "points to /path/to/target"
            ┌──────────┐                  ▼
            │  INODE   │           ┌─────────────┐
            │  #12345  │           │   target    │
            └──────────┘           └──────┬──────┘
                  ▲                       │
┌─────────────┐   │                       ▼
│ filename2   │───┘                ┌──────────┐
└─────────────┘                    │  INODE   │
                                   │  #67890  │
Same inode, same data              └──────────┘
Delete one, other remains          Delete target, symlink breaks
```

```bash
# Create hard link
echo "hello" > original.txt
ln original.txt hardlink.txt

# Create symbolic link
ln -s original.txt symlink.txt

# Compare
ls -li original.txt hardlink.txt symlink.txt

# Output:
# 123456 -rw-r--r-- 2 user user 6 Dec 1 original.txt    ← inode 123456
# 123456 -rw-r--r-- 2 user user 6 Dec 1 hardlink.txt    ← same inode!
# 789012 lrwxrwxrwx 1 user user 12 Dec 1 symlink.txt → original.txt

# Delete original - what happens?
rm original.txt
cat hardlink.txt  # Still works! (inode still exists)
cat symlink.txt   # Broken! (target gone)
```

### Why This Matters for Containers

Container images use hard links and copy-on-write:

```
Image Layer 1 (base)
    └── /usr/bin/bash  → inode 1001

Image Layer 2 (app)
    └── /app/myapp     → inode 2001

Container (overlay)
    └── /usr/bin/bash  → references layer 1's inode (efficient!)
    └── /app/myapp     → references layer 2's inode
    └── /app/data      → new inode (container-specific)
```

---

## Mount Points

Filesystems are attached to the directory tree via mount points.

### Understanding Mounts

```
┌─────────────────────────────────────────────────────────┐
│                      /  (root)                          │
│                    ext4 on /dev/sda1                    │
├─────────────────────────────────────────────────────────┤
│        │                    │                    │       │
│        ▼                    ▼                    ▼       │
│   ┌─────────┐         ┌─────────┐          ┌─────────┐  │
│   │  /boot  │         │  /home  │          │  /var   │  │
│   │ext4/sda2│         │xfs /sda3│          │ext4/sda4│  │
│   └─────────┘         └─────────┘          └─────────┘  │
│                             │                           │
│                             ▼                           │
│                       ┌──────────┐                      │
│                       │ /home/nfs│                      │
│                       │  NFS     │                      │
│                       └──────────┘                      │
└─────────────────────────────────────────────────────────┘
```

### Viewing Mounts

```bash
# All mounts
mount | head -20

# More readable
findmnt

# Specific filesystem
findmnt -t ext4

# From /proc
cat /proc/mounts | head -10
```

### /etc/fstab — Persistent Mounts

```bash
# /etc/fstab format:
# <device>       <mount point>  <type>  <options>        <dump> <fsck>
/dev/sda1        /              ext4    defaults         0      1
/dev/sda2        /boot          ext4    defaults         0      2
/dev/sda3        /home          xfs     defaults         0      2
UUID=abc-123     /data          ext4    defaults,noatime 0      2
192.168.1.10:/   /mnt/nfs       nfs     defaults         0      0
```

### Try This: Temporary Mount

```bash
# Create a tmpfs (RAM disk)
mkdir -p /tmp/ramdisk
sudo mount -t tmpfs -o size=100M tmpfs /tmp/ramdisk

# Verify
df -h /tmp/ramdisk
mount | grep ramdisk

# Use it
echo "This is in RAM" > /tmp/ramdisk/test.txt

# Unmount
sudo umount /tmp/ramdisk
```

---

## Kubernetes-Relevant Paths

| Path | Purpose |
|------|---------|
| `/etc/kubernetes/` | Kubernetes configuration |
| `/etc/kubernetes/manifests/` | Static pod manifests |
| `/etc/kubernetes/pki/` | Certificates |
| `/var/lib/kubelet/` | Kubelet data |
| `/var/lib/kubelet/pods/` | Pod volumes |
| `/var/lib/containerd/` | Container runtime data |
| `/var/log/pods/` | Pod logs |
| `/var/log/containers/` | Container logs (symlinks) |
| `/run/containerd/` | containerd socket and runtime |

```bash
# On a Kubernetes node
ls /etc/kubernetes/ 2>/dev/null || echo "Not a K8s node"
ls /var/lib/kubelet/pods/ 2>/dev/null | head -5
```

---

## Common Mistakes

| Mistake | Problem | Solution |
|---------|---------|----------|
| Putting data in `/tmp` | Lost on reboot | Use `/var/lib/` for persistent data |
| Filling `/var` | System breaks | Monitor disk usage, rotate logs |
| Modifying files in `/proc` without understanding | System instability | Research sysctl parameters first |
| Symlink confusion | Following/not following symlinks | Use `ls -l` to check, `-L` flag with commands |
| Forgetting mount namespaces | Container sees different mounts | Remember containers have isolated mounts |
| Running out of inodes | Can't create files even with space | Check `df -i` |

---

## Quiz

### Question 1
What's the difference between /proc and /sys?

<details>
<summary>Show Answer</summary>

Both are virtual filesystems, but:
- **/proc** focuses on **processes and runtime system information** (PIDs, memory, CPU, network connections)
- **/sys** exposes **kernel objects, devices, and drivers** (hardware configuration, cgroup info, device classes)

/proc is older and more process-centric; /sys is more hardware/kernel-object oriented.

</details>

### Question 2
Why can two files have the same inode number?

<details>
<summary>Show Answer</summary>

They're **hard links** — different directory entries pointing to the same inode. The file data exists once, but multiple names reference it.

Both names are equally "real" — deleting one doesn't affect the other. The inode (and data) is only deleted when the link count reaches zero.

</details>

### Question 3
Where would you find the kubelet's persistent data?

<details>
<summary>Show Answer</summary>

**/var/lib/kubelet/**

Following FHS:
- `/var` = variable data (changes during operation)
- `/var/lib` = persistent application state
- `/var/lib/kubelet` = kubelet-specific data (pod volumes, plugins, etc.)

</details>

### Question 4
What happens if /var/log fills up?

<details>
<summary>Show Answer</summary>

**System instability or failure**:
- Services can't write logs → crash or hang
- systemd journal may fail
- Audit logs can't be written → security implications
- Container runtimes may fail

Solutions: Log rotation (logrotate), monitoring disk space, using separate partition for /var.

</details>

### Question 5
How do you find what filesystem type a directory uses?

<details>
<summary>Show Answer</summary>

```bash
# Most readable
findmnt /path/to/directory

# Or
df -T /path/to/directory

# Or check mount
mount | grep " /path"

# Or stat
stat -f /path/to/directory
```

</details>

---

## Hands-On Exercise

### Exploring the Filesystem

**Objective**: Navigate the Linux filesystem and understand what lives where.

**Environment**: Any Linux system

#### Part 1: Directory Exploration

```bash
# 1. What's in root?
ls -la /

# 2. Find configuration files
ls /etc | wc -l
echo "There are $(ls /etc | wc -l) items in /etc"

# 3. Check important config files
head -5 /etc/passwd
head -5 /etc/hosts

# 4. Find your DNS servers
cat /etc/resolv.conf
```

#### Part 2: Virtual Filesystems

```bash
# 1. System information from /proc
echo "Uptime: $(cat /proc/uptime | cut -d' ' -f1) seconds"
echo "Load: $(cat /proc/loadavg)"
echo "Memory: $(grep MemTotal /proc/meminfo)"

# 2. Your process's view
echo "My PID: $$"
ls /proc/$$/
cat /proc/$$/status | head -10

# 3. Network info from /proc
cat /proc/net/dev | head -5

# 4. Kernel parameters from /sys
ls /sys/class/net/
```

#### Part 3: Inodes and Links

```bash
# 1. Create test files
cd /tmp
echo "original content" > original.txt

# 2. Create hard link
ln original.txt hardlink.txt

# 3. Create symbolic link
ln -s original.txt symlink.txt

# 4. Examine inodes
ls -li original.txt hardlink.txt symlink.txt

# 5. Modify through hard link
echo "modified" >> hardlink.txt
cat original.txt  # Also modified!

# 6. Delete original
rm original.txt
cat hardlink.txt   # Works!
cat symlink.txt    # Broken!

# 7. Check inode usage
df -i / | head -2
```

#### Part 4: Mounts and Space

```bash
# 1. View all mounts
findmnt | head -20

# 2. Disk space usage
df -h

# 3. Find largest directories
du -sh /var/* 2>/dev/null | sort -h | tail -10

# 4. Check mount options
findmnt -o TARGET,FSTYPE,OPTIONS /
```

### Success Criteria

- [ ] Located key system configuration files
- [ ] Read process information from /proc
- [ ] Understood hard links vs symbolic links
- [ ] Checked disk usage and mount points

---

## Key Takeaways

1. **Everything is a file** — Even devices, processes, and system info are accessed through the filesystem

2. **FHS provides predictability** — Configuration in /etc, logs in /var/log, binaries in /bin and /usr/bin

3. **/proc and /sys are virtual** — Generated by the kernel, essential for monitoring and debugging

4. **Inodes are the real identity** — Filenames are just pointers; understanding this explains links and storage

5. **Know Kubernetes paths** — /etc/kubernetes, /var/lib/kubelet, /var/log/pods

---

## What's Next?

In **Module 1.4: Users & Permissions**, you'll learn how Linux controls who can access files and run commands—essential for understanding container security.

---

## Further Reading

- [Filesystem Hierarchy Standard](https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html)
- [The /proc Filesystem](https://www.kernel.org/doc/html/latest/filesystems/proc.html)
- [Linux Filesystem Explained](https://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/)
- [inode and Links](https://www.howtogeek.com/465350/everything-you-ever-wanted-to-know-about-inodes-on-linux/)

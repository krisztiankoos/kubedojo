# Module 3.4: iptables & netfilter

> **Linux Foundations** | Complexity: `[COMPLEX]` | Time: 35-40 min

## Prerequisites

Before starting this module:
- **Required**: [Module 3.1: TCP/IP Essentials](module-3.1-tcp-ip-essentials.md)
- **Required**: [Module 3.3: Network Namespaces](module-3.3-network-namespaces.md)
- **Helpful**: Basic understanding of firewalls

---

## Why This Module Matters

iptables (and netfilter) is the packet filtering and manipulation framework in Linux. It powers:

- **Kubernetes Services** — ClusterIP, NodePort use iptables rules
- **Network Policies** — Filtering between pods
- **NAT** — How containers reach the internet
- **Load Balancing** — kube-proxy iptables mode

When services don't work, pods can't communicate, or traffic doesn't flow as expected—understanding iptables is essential for debugging.

---

## Did You Know?

- **A busy Kubernetes node can have 10,000+ iptables rules** — Each service creates multiple rules. This is why kube-proxy has IPVS mode for large clusters (better performance).

- **iptables is just the CLI** — The actual packet filtering happens in the kernel's netfilter subsystem. iptables is the user-space tool to configure it.

- **iptables dates back to 2001** (Linux 2.4). Its predecessor, ipchains (2.2), was even simpler. Modern systems are moving to nftables, but iptables is still dominant.

- **Every Kubernetes service creates at least 5 iptables rules** — For the KUBE-SERVICES chain, plus per-endpoint rules. With 100 services × 3 endpoints each, that's 1500+ rules.

---

## Netfilter Architecture

### Packet Flow Through Netfilter

```
┌─────────────────────────────────────────────────────────────────┐
│                    NETFILTER PACKET FLOW                         │
│                                                                  │
│                       Incoming Packet                            │
│                            │                                     │
│                            ▼                                     │
│                     ┌──────────────┐                            │
│                     │  PREROUTING  │  (raw, mangle, nat)        │
│                     └──────┬───────┘                            │
│                            │                                     │
│               ┌────────────▼────────────┐                       │
│               │    Routing Decision     │                       │
│               └────────────┬────────────┘                       │
│                    ┌───────┴───────┐                            │
│                    ▼               ▼                            │
│  ┌─────────────────────┐  ┌─────────────────────┐              │
│  │      INPUT          │  │     FORWARD         │              │
│  │  (for this host)    │  │  (for other host)   │              │
│  └──────────┬──────────┘  └──────────┬──────────┘              │
│             │                        │                          │
│             ▼                        │                          │
│     Local Process                    │                          │
│             │                        │                          │
│             ▼                        │                          │
│  ┌─────────────────────┐            │                          │
│  │      OUTPUT         │            │                          │
│  │  (from this host)   │            │                          │
│  └──────────┬──────────┘            │                          │
│             │                        │                          │
│             └────────────┬───────────┘                          │
│                          ▼                                      │
│                   ┌──────────────┐                              │
│                   │ POSTROUTING  │  (mangle, nat)               │
│                   └──────┬───────┘                              │
│                          │                                      │
│                          ▼                                      │
│                    Outgoing Packet                              │
└─────────────────────────────────────────────────────────────────┘
```

### The Five Chains

| Chain | Purpose | When |
|-------|---------|------|
| PREROUTING | Before routing decision | Incoming packets |
| INPUT | For local delivery | Destined for this host |
| FORWARD | For routing | Passing through this host |
| OUTPUT | From local processes | Generated by this host |
| POSTROUTING | After routing | Leaving this host |

### The Tables

| Table | Purpose | Chains |
|-------|---------|--------|
| filter | Accept/drop packets | INPUT, FORWARD, OUTPUT |
| nat | Address translation | PREROUTING, OUTPUT, POSTROUTING |
| mangle | Packet modification | All chains |
| raw | Connection tracking exceptions | PREROUTING, OUTPUT |

---

## iptables Basics

### Rule Structure

```
iptables -t <table> -A <chain> <match> -j <target>

Example:
iptables -t filter -A INPUT -p tcp --dport 22 -j ACCEPT
         │         │        │                   │
         │         │        │                   └── Action: Accept
         │         │        └── Match: TCP port 22
         │         └── Append to INPUT chain
         └── Table: filter (default)
```

### Common Targets

| Target | Action |
|--------|--------|
| ACCEPT | Allow packet |
| DROP | Silently discard |
| REJECT | Discard with error |
| LOG | Log and continue |
| SNAT | Source NAT |
| DNAT | Destination NAT |
| MASQUERADE | Dynamic SNAT |
| RETURN | Return from chain |

### Viewing Rules

```bash
# List all filter rules
sudo iptables -L -n -v

# List specific chain
sudo iptables -L INPUT -n -v

# List nat table
sudo iptables -t nat -L -n -v

# Show line numbers (useful for deletion)
sudo iptables -L INPUT -n --line-numbers

# Show rules as commands
sudo iptables-save
```

---

## Practical iptables

### Basic Firewall Rules

```bash
# Accept established connections
sudo iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Accept loopback
sudo iptables -A INPUT -i lo -j ACCEPT

# Accept SSH
sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT

# Accept HTTP/HTTPS
sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT

# Drop everything else
sudo iptables -A INPUT -j DROP
```

### NAT Examples

```bash
# MASQUERADE: Source NAT for containers (dynamic)
sudo iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o eth0 -j MASQUERADE

# SNAT: Source NAT with specific IP
sudo iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o eth0 -j SNAT --to-source 192.168.1.100

# DNAT: Destination NAT (port forwarding)
sudo iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 10.0.0.5:80

# Redirect to local port
sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080
```

### Managing Rules

```bash
# Insert at position (vs append)
sudo iptables -I INPUT 1 -p tcp --dport 22 -j ACCEPT

# Delete by specification
sudo iptables -D INPUT -p tcp --dport 22 -j ACCEPT

# Delete by line number
sudo iptables -D INPUT 3

# Flush all rules in chain
sudo iptables -F INPUT

# Flush all rules
sudo iptables -F

# Save rules (Debian/Ubuntu)
sudo iptables-save > /etc/iptables/rules.v4

# Restore rules
sudo iptables-restore < /etc/iptables/rules.v4
```

---

## Kubernetes and iptables

### kube-proxy iptables Mode

kube-proxy creates iptables rules for Services.

```
┌─────────────────────────────────────────────────────────────────┐
│              KUBERNETES SERVICE IPTABLES                         │
│                                                                  │
│  Service: my-svc (ClusterIP: 10.96.0.100, Port: 80)            │
│  Endpoints: 10.244.1.5:8080, 10.244.2.6:8080                   │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ KUBE-SERVICES chain:                                     │   │
│  │   -d 10.96.0.100/32 -p tcp --dport 80 -j KUBE-SVC-XXX   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                            │                                    │
│                            ▼                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ KUBE-SVC-XXX chain (load balancing):                    │   │
│  │   -m statistic --probability 0.5 -j KUBE-SEP-AAA        │   │
│  │   -j KUBE-SEP-BBB                                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                    │                  │                         │
│                    ▼                  ▼                         │
│  ┌─────────────────────┐  ┌─────────────────────┐              │
│  │ KUBE-SEP-AAA:       │  │ KUBE-SEP-BBB:       │              │
│  │  DNAT to 10.244.1.5 │  │  DNAT to 10.244.2.6 │              │
│  └─────────────────────┘  └─────────────────────┘              │
└─────────────────────────────────────────────────────────────────┘
```

### Viewing Kubernetes iptables Rules

```bash
# All service-related rules
sudo iptables -t nat -L KUBE-SERVICES -n

# Find rules for a specific service
sudo iptables-save | grep "my-service"

# Count rules
sudo iptables-save | wc -l
sudo iptables -t nat -L | wc -l
```

### NodePort Implementation

```
┌─────────────────────────────────────────────────────────────────┐
│                  NODEPORT IPTABLES                               │
│                                                                  │
│  Service: my-svc NodePort 30080                                 │
│                                                                  │
│  1. KUBE-NODEPORTS chain catches traffic to 30080              │
│     -p tcp --dport 30080 -j KUBE-SVC-XXX                       │
│                                                                  │
│  2. KUBE-SVC-XXX forwards to endpoints (same as ClusterIP)     │
│                                                                  │
│  3. If externalTrafficPolicy: Local, only local endpoints      │
│     KUBE-XLB-XXX chain filters                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Network Policies

Network policies also use iptables (or eBPF in Cilium).

```bash
# Network policy rules (typically in KUBE-NWPLCY chains)
sudo iptables -L KUBE-NWPLCY-* -n 2>/dev/null

# Calico uses its own chains
sudo iptables -L cali-* -n 2>/dev/null | head -50
```

---

## iptables vs IPVS vs eBPF

### Comparison

| Feature | iptables | IPVS | eBPF (Cilium) |
|---------|----------|------|---------------|
| Rule complexity | O(n) | O(1) hash | O(1) |
| Large clusters | Slow | Fast | Fastest |
| Setup complexity | Simple | Medium | Complex |
| Load balancing | Random | Multiple algos | Multiple algos |
| Connection tracking | conntrack | Built-in | Efficient |

### When to Use What

```
Small cluster (< 100 services): iptables is fine
Medium cluster (100-1000 services): Consider IPVS
Large cluster (1000+ services): IPVS or eBPF
Advanced features needed: eBPF (Cilium)
```

### Checking kube-proxy Mode

```bash
# Check kube-proxy mode
kubectl get configmap kube-proxy -n kube-system -o yaml | grep mode

# Or check logs
kubectl logs -n kube-system -l k8s-app=kube-proxy | head -50
```

---

## Debugging iptables

### Tracing Packets

```bash
# Enable tracing
sudo iptables -t raw -A PREROUTING -p tcp --dport 80 -j TRACE
sudo iptables -t raw -A OUTPUT -p tcp --dport 80 -j TRACE

# View traces
sudo dmesg | grep TRACE

# Or
sudo tail -f /var/log/kern.log | grep TRACE

# Don't forget to remove trace rules when done!
```

### Common Issues

```bash
# Check if traffic is hitting rules
sudo iptables -L INPUT -n -v
# Look at packet/byte counters

# Check NAT
sudo iptables -t nat -L -n -v

# Check for DROP rules
sudo iptables-save | grep DROP

# Watch counters in real-time
watch -n1 'sudo iptables -L INPUT -n -v'
```

### Packet Counters

```bash
# Reset counters
sudo iptables -Z

# View counters (pkts and bytes columns)
sudo iptables -L -n -v

# Find rules with traffic
sudo iptables-save -c | grep -v "0:0"
```

---

## Common Mistakes

| Mistake | Problem | Solution |
|---------|---------|----------|
| Rule order wrong | Traffic hits wrong rule | Check order, use -I for priority |
| Forgot state tracking | Responses blocked | Add ESTABLISHED,RELATED rule |
| Flushed rules remotely | Locked out | Use iptables-apply or console |
| Missing FORWARD rules | Containers can't route | Enable and configure FORWARD |
| NAT without forwarding | NAT doesn't work | Enable ip_forward sysctl |
| Too many rules | Performance degradation | Consider IPVS |

---

## Quiz

### Question 1
What's the difference between DROP and REJECT targets?

<details>
<summary>Show Answer</summary>

- **DROP**: Silently discards the packet. Sender gets no response and eventually times out.
- **REJECT**: Sends an ICMP error back (e.g., "port unreachable"). Sender knows immediately.

DROP is more "secure" (reveals less about firewall), REJECT is more "polite" (faster failure for legitimate traffic).

</details>

### Question 2
How does kube-proxy implement load balancing with iptables?

<details>
<summary>Show Answer</summary>

Using the **statistic module** with probability:

```
-m statistic --mode random --probability 0.5 -j KUBE-SEP-AAA
-j KUBE-SEP-BBB
```

For 2 endpoints: 50% chance of first rule (endpoint A), otherwise falls through to endpoint B.

For 3 endpoints: 33% first, 50% of remaining (33%) second, rest to third.

This is why it's called "random" load balancing.

</details>

### Question 3
What table is used for NAT operations?

<details>
<summary>Show Answer</summary>

The **nat** table. It has three chains:
- **PREROUTING**: DNAT (change destination before routing)
- **OUTPUT**: DNAT for locally-generated packets
- **POSTROUTING**: SNAT/MASQUERADE (change source after routing)

Kubernetes uses DNAT to redirect ClusterIP traffic to pod endpoints.

</details>

### Question 4
Why might a Kubernetes cluster with many services perform poorly with iptables mode?

<details>
<summary>Show Answer</summary>

iptables rule matching is **O(n)** — packets traverse rules sequentially until a match.

With 1000 services × ~5 rules each = 5000+ rules. Each packet potentially traverses thousands of rules.

Solutions:
- Use **IPVS mode** (O(1) hash lookup)
- Use **Cilium/eBPF** (kernel-level efficiency)
- Reduce number of services

</details>

### Question 5
What does `iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o eth0 -j MASQUERADE` do?

<details>
<summary>Show Answer</summary>

**Source NAT for outgoing traffic**:
- `-t nat`: NAT table
- `-A POSTROUTING`: After routing decision
- `-s 10.0.0.0/24`: Source is internal network
- `-o eth0`: Going out eth0
- `-j MASQUERADE`: Replace source IP with eth0's IP

This allows internal hosts (containers) to reach the internet by appearing to come from the host's IP.

</details>

---

## Hands-On Exercise

### iptables Exploration

**Objective**: Understand iptables rules and how Kubernetes uses them.

**Environment**: Linux system, ideally with Kubernetes

#### Part 1: Basic iptables

```bash
# 1. View current rules
sudo iptables -L -n -v

# 2. View NAT rules
sudo iptables -t nat -L -n -v

# 3. Save current rules
sudo iptables-save > /tmp/iptables-backup.txt
cat /tmp/iptables-backup.txt
```

#### Part 2: Create Simple Rules

```bash
# 1. Create a test chain
sudo iptables -N TEST_CHAIN

# 2. Add rules to chain
sudo iptables -A TEST_CHAIN -p icmp -j LOG --log-prefix "PING: "
sudo iptables -A TEST_CHAIN -p icmp -j ACCEPT

# 3. Link from INPUT
sudo iptables -A INPUT -j TEST_CHAIN

# 4. Test (ping yourself)
ping -c 2 127.0.0.1

# 5. Check logs
sudo dmesg | grep "PING:" | tail -5

# 6. Check counters
sudo iptables -L TEST_CHAIN -n -v

# 7. Cleanup
sudo iptables -D INPUT -j TEST_CHAIN
sudo iptables -F TEST_CHAIN
sudo iptables -X TEST_CHAIN
```

#### Part 3: NAT Example

```bash
# 1. Enable forwarding
sudo sysctl -w net.ipv4.ip_forward=1

# 2. View current NAT
sudo iptables -t nat -L -n -v

# 3. Add a port redirect (local)
sudo iptables -t nat -A OUTPUT -p tcp --dport 8888 -j REDIRECT --to-port 80

# 4. Test (if web server on 80)
# curl localhost:8888  # Would go to localhost:80

# 5. Remove rule
sudo iptables -t nat -D OUTPUT -p tcp --dport 8888 -j REDIRECT --to-port 80
```

#### Part 4: Kubernetes iptables (if available)

```bash
# 1. Count Kubernetes rules
sudo iptables-save | grep -c KUBE

# 2. View service chains
sudo iptables -t nat -L KUBE-SERVICES -n | head -20

# 3. Trace a specific service
# Find your service's ClusterIP
kubectl get svc my-service -o wide

# Find iptables rules for it
sudo iptables-save | grep <ClusterIP>

# 4. View DNAT rules
sudo iptables -t nat -L -n | grep DNAT | head -10
```

#### Part 5: Rule Analysis

```bash
# 1. Find busiest rules (most packets)
sudo iptables -L -n -v | sort -k1 -n -r | head -10

# 2. Find all DROP rules
sudo iptables-save | grep DROP

# 3. Count rules by table
echo "filter: $(sudo iptables -L | wc -l)"
echo "nat: $(sudo iptables -t nat -L | wc -l)"
echo "mangle: $(sudo iptables -t mangle -L | wc -l)"
```

### Success Criteria

- [ ] Viewed and understood iptables output
- [ ] Created and tested a custom chain
- [ ] Understood NAT rule syntax
- [ ] (Kubernetes) Found service-related iptables rules
- [ ] Can interpret rule counters

---

## Key Takeaways

1. **netfilter is the engine** — iptables is just the configuration tool

2. **Five chains, four tables** — Know the packet flow through them

3. **Kubernetes relies on iptables** — Services, NodePorts, network policies

4. **Rule order matters** — First match wins

5. **Performance at scale** — Consider IPVS or eBPF for large clusters

---

## What's Next?

Congratulations! You've completed the **Networking** section of Linux Foundations. You now understand:
- TCP/IP fundamentals
- DNS resolution
- Network namespaces and container networking
- iptables and how Kubernetes uses it

Next, continue to **Section 4: Security/Hardening** to learn about kernel hardening, AppArmor, SELinux, and seccomp.

---

## Further Reading

- [Netfilter Documentation](https://netfilter.org/documentation/)
- [iptables Tutorial](https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html)
- [Kubernetes Network Plugins](https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/)
- [Life of a Packet in Kubernetes](https://dramasamy.medium.com/life-of-a-packet-in-kubernetes-part-1-f9bc0909e051)
